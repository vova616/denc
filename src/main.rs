#![feature(await_macro, async_await, futures_api, generators)]
#![feature(const_fn)]

#[macro_use]
extern crate lazy_static;

use std::pin::*;

use std::io;

use futures::prelude::*;
use runtime::net::tcp::{TcpListener, TcpStream};

use std::net::SocketAddr;

use std::net::Shutdown;
use std::{thread, time};

use std::sync::atomic::{AtomicUsize, Ordering};
use bytes::{Bytes, BytesMut, Buf, BufMut, IntoBuf};
use std::sync::{RwLock, Arc, Mutex};
use std::str;

use futures::{FutureExt, TryFutureExt, SinkExt};
use futures::channel::mpsc;
use futures::stream::Buffered;
use futures::{Future};

use runtime_native;

use std::io::prelude::*;

use evmap;
use evmap::shallow_copy::CopyValue;

use mapper::{Decoder,Encoder};

pub mod cryptor;
pub mod packet;

#[derive(Debug)]
struct Client<T> {
    pub id: usize,
    pub user_id: Option<usize>,

    pub writer: T
}

//impl<T: tokio::prelude::SinkExt<SinkItem=BytesMut, SinkError=mpsc::SendError> + std::marker::Unpin + Clone> Client<T> {
impl<T: Sink<BytesMut, SinkError=mpsc::SendError> + std::marker::Unpin + Clone> Client<T> {
    pub async fn send(&self, mut bytes: BytesMut) {
        let lenBytes = u16::to_le_bytes(bytes.len() as u16);
        bytes[0] = lenBytes[0];
        bytes[1] = lenBytes[1];
        println!("sending {:02X?}", &bytes[..]);

        if bytes[2] == 1 {
            cryptor::decrypt_hybrid_16(&mut bytes[4..]);
        }


        let mut writer = self.writer.clone();
        loop {
            match await!(writer.send(bytes.clone())) {
                Ok(x) => {
                    break;
                },
                Err(e) => {
                    if e.is_disconnected() {
                        println!("Send Channel: Disconnected");
                        return
                    }
                    println!("Channel not ready {:?}", e);
                },
            }
        }
    }
}


use std::collections::HashMap;

#[derive(Debug)]
pub struct ProtocolCodec;

/*
impl Decoder for ProtocolCodec  {
    type Item = BytesMut;
    type Error = io::Error;

    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<BytesMut>> {
        if buf.len() >= 2
        {
            let len = u16::from_le_bytes([buf[0], buf[1]]) as usize;
            if buf.len() >= len {
                let mut result = buf.split_to(len);
                Ok(Some(result))
            } else {
                Ok(None)
            }
        } else {
            Ok(None)
        }
    }
}
*/

/*
// ===== Mock ======
use std::collections::VecDeque;
struct Mock {
    calls: VecDeque<io::Result<Vec<u8>>>,
}

macro_rules! mock {
    ($($x:expr,)*) => {{
        let mut v = VecDeque::new();
        v.extend(vec![$($x),*]);
        Mock { calls: v }
    }};
}

impl Read for Mock {
    fn read(&mut self, dst: &mut [u8]) -> io::Result<usize> {
        match self.calls.pop_front() {
            Some(Ok(data)) => {
                debug_assert!(dst.len() >= data.len());
                dst[..data.len()].copy_from_slice(&data[..]);
                Ok(data.len())
            }
            Some(Err(e)) => Err(e),
            None => Ok(0),
        }
    }
}

impl AsyncRead for Mock {

}
*/

async fn login_server() -> Result<(), failure::Error> {
    let ids = AtomicUsize::new(0);

    let mut listener = TcpListener::bind("0.0.0.0:2000")?;
    println!("Listening on {}", listener.local_addr()?);

    use packet::send;

    let mut incoming = listener.incoming();
    while let Some(stream) = await!(incoming.next()) {
        let mut stream: TcpStream = stream.unwrap();


        let (mut reader,mut writer) = stream.split();

        let (mut send_sender,mut send_receiver) = mpsc::channel::<BytesMut>(20);

        let id = ids.fetch_add(1, Ordering::SeqCst);

        let mut client = Arc::new(Client{id: id, user_id: None, writer: send_sender});
        let (mut recv_sender,mut recv_receiver) = mpsc::channel::<BytesMut>(20);



        //let mut reader = FramedRead::new(reader, ProtocolCodec{});

        runtime::spawn(async move {
            let mut buff = BytesMut::with_capacity(1024*10);
            let mut index = 0;
            loop {
                buff.resize(index+1024, 0);
                match await!(reader.read(&mut buff[index..index+1024])) {
                    Ok(len) => {
                        println!("recv len {}", len);

                        index += len;
                        if len == 0 {
                            break;
                        }
                        if index < 2 {
                            continue;
                        }

                        let mut size = u16::from_le_bytes([buff[0], buff[1]]) as usize;
                        while size <= index {
                            let mut bytes = buff.split_to(size);
                            loop {
                                match await!(recv_sender.send(bytes.clone())) {
                                    Ok(x) => {
                                        break;
                                    },
                                    Err(e) => {
                                        if e.is_disconnected() {
                                            println!("Send Channel: Disconnected");
                                            return
                                        }
                                        println!("Channel not ready {}", e);
                                    },
                                }
                            }

                            index -= size;
                            if index >= 2 {
                                size = u16::from_le_bytes([buff[0], buff[1]]) as usize;
                            } else {
                                break;
                            }
                        }

                    },
                    Err(e)  => {
                        println!("Error on recv client {:?}", e);
                        break;
                    }
                }
            }
        });

        runtime::spawn(async move {
            {
                let buff = [0x0A,0x00,0x00,0x00,0x64, 0x00, 0x00, 0x00, 0x00, 0x01];
                let buff = BytesMut::from(&buff[..]);

                await!(client.send(buff));
            }

            loop {
                match await!(recv_receiver.next()) {
                    Some(mut bytes) => {
                        if bytes[2] == 0x01 {
                            cryptor::decrypt_hybrid_16(&mut bytes[4..]);
                        }
                        let header = packet::Header::decode(&bytes[..8]);
                        let mut data = &mut bytes[8..];
                        println!("recv {:02X?}", &data[..]);
                        println!("header {:02X?}", header.id);

                        match header.id {
                            0x65 => {
                                let packet = packet::Packet::new(send::Hello::new());
                                await!(client.send(packet.into()));
                            },
                            0xBEBC207 => {
                                let buff = [0x49, 0x00, 0x01, 0x00, 0x01, 0xC2, 0xEB, 0x0B, 0x00, 0xE7, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56, 0x6F, 0x76, 0x63, 0x68, 0x69, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));
                            },
                            0x012C => {
                                let buff = [0x18, 0x00, 0x01, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x31, 0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x07];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));

                                let buff = [0x76, 0x00, 0x01, 0x00, 0x69, 0xD2, 0xEB, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));

                                let buff = [0x10, 0x00, 0x01, 0x00, 0x2D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));
                            },
                            0xBEBC264 => {
                                let buff = [0x0c,0x00,0x01,0x00, 0x65, 0xC2, 0xEB, 0x0B, 0x01, 0x01, 0x00, 0x53, 0x65, 0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x31, 0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x07, 0x01, 0x02];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));
                            },
                            0xBEBC268 => {
                                let buff = [0x0c,0x00,0x01,0x00, 0x69, 0xC2, 0xEB, 0x0B, 0x08, 0x6A, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6B, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));
                            },
                            0xBEBC26B => {
                                let buff = [0x0c,0x00,0x01,0x00, 0x6C, 0xC2, 0xEB, 0x0B, 0x00, 0x31, 0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x00, 0x00, 0x00, 0xD2, 0x07 ];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));
                            },
                            0x012e => {
                                let buff = [0x0c,0x00,0x01,0x00, 0x2F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ];
                                let buff = BytesMut::from(&buff[..]);
                                await!(client.send(buff));
                            },
                            _ => {
                                println!("Unknown id {:02X?}", header.id)
                            }
                        }
                    },
                    None => {
                        println!("Recv Channel: closed");
                        break;
                    }
                }
            }
        });

        runtime::spawn(async move {
            loop {
                match await!(send_receiver.next()) {
                    Some(mut bytes) => {
                        println!("sent {:02X?}", &bytes[..]);
                        await!(writer.write_all(&bytes[..]));
                    },
                    None => {
                        println!("Send Channel: closed");
                        break;
                    }
                }
            }
        });
    }

    Ok(())
}

async fn char_server() -> Result<(), failure::Error> {
    let clients = Arc::new(RwLock::new(HashMap::new()));
    let ids = AtomicUsize::new(0);

    let mut listener = TcpListener::bind("0.0.0.0:2001")?;
    println!("Listening on {}", listener.local_addr()?);

    let mut incoming = listener.incoming();
    while let Some(stream) = await!(incoming.next()) {
        let mut stream: TcpStream = stream.unwrap();


        let (mut reader,mut writer) = stream.split();

        let (mut send_sender,mut send_receiver) = mpsc::channel::<BytesMut>(20);

        let id = ids.fetch_add(1, Ordering::SeqCst);

        let mut client = Arc::new(Client{id: id, user_id: None, writer: send_sender});
        let (mut recv_sender,mut recv_receiver) = mpsc::channel::<BytesMut>(20);

        let clients = clients.clone();
        loop {
            match clients.try_write() {
                Ok(mut hash) => {
                    println!("Insert Client {}", id);
                    hash.insert(id, client.clone());
                    break;
                }
                _ => {}
            }
        }

        {
            let buff = [0x0A,0x00,0x00,0x00,0x64, 0x00, 0x00, 0x00, 0x00, 0x01];
            let buff = BytesMut::from(&buff[..]);

            await!(client.send(buff));
        }

        runtime::spawn(async move {
            let mut buff = BytesMut::with_capacity(1024*10);
            let mut index = 0;
            loop {
                buff.resize(index+1024, 0);
                match await!(reader.read(&mut buff[index..index+1024])) {
                    Ok(len) => {
                        println!("recv len {}", len);

                        index += len;
                        if len == 0 {
                            break;
                        }
                        if index < 2 {
                            continue;
                        }

                        let mut size = u16::from_le_bytes([buff[0], buff[1]]) as usize;
                        while size <= index {
                            let mut bytes = buff.split_to(size);
                            loop {
                                match await!(recv_sender.send(bytes.clone())) {
                                    Ok(x) => {
                                        break;
                                    },
                                    Err(e) => {
                                        if e.is_disconnected() {
                                            println!("Send Channel: Disconnected");
                                            return
                                        }
                                        println!("Channel not ready {}", e);
                                    },
                                }
                            }

                            index -= size;
                            if index >= 2 {
                                size = u16::from_le_bytes([buff[0], buff[1]]) as usize;
                            } else {
                                break;
                            }
                        }

                    },
                    Err(e)  => {
                        println!("Error on recv client {:?}", e);
                        break;
                    }
                }
            }

            loop {
                match clients.try_write() {
                    Ok(mut hash) => {
                        println!("Remove Client DC {}", id);
                        hash.remove(&id);
                        break;
                    }
                    _ => {}
                }
            }
        });

        runtime::spawn(async move {
            loop {
                match await!(recv_receiver.next()) {
                    Some(mut bytes) => {
                        if bytes[2] == 1 {
                            cryptor::decrypt(&mut bytes[4..]);
                        }
                        println!("recv {:02X?}", &bytes[..]);

                        if bytes[4] == 0x65 {
                            let buff = [0x0c,0x00,0x01,0x00,0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                            let buff = BytesMut::from(&buff[..]);
                            await!(client.send(buff));
                        }
                        if bytes[4] == 0x2c  {
                            let buff = [0x10, 0x00, 0x01, 0x00, 0x2D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                            let buff = BytesMut::from(&buff[..]);
                            await!(client.send(buff));
                        }
                        if bytes[4] == 0xCC {
                            let buff = [0x0c,0x00,0x01,0x00,0xF1, 0xC2, 0xEB, 0x0B, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01];
                            let buff = BytesMut::from(&buff[..]);
                            await!(client.send(buff));

                            let buff = [0x0c,0x00,0x01,0x00,0xF1, 0xC2, 0xEB, 0x0B, 0x00, 0x02, 0x67, 0xDC, 0x01, 0x00, 0x01, 0x00, 0x10, 0x30, 0x64, 0x44, 0x6F, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x85, 0xCE, 0x38, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x25, 0xD1, 0xCC, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x85, 0x2B, 0xC1, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x05, 0xC2, 0x59, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x85, 0x58, 0xF2, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0D, 0xFE, 0xC5, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x04, 0x51, 0x2D, 0x3B, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x05, 0x51, 0xA9, 0xCD, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x51, 0x03, 0x30, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
                            let buff = BytesMut::from(&buff[..]);
                            await!(client.send(buff));

                            let buff = [0x0c,0x00,0x01,0x00,0xF1, 0xC2, 0xEB, 0x0B, 0x00, 0x03];
                            let buff = BytesMut::from(&buff[..]);
                            await!(client.send(buff));
                        }
                    },
                    None => {
                        println!("Recv Channel: closed");
                        break;
                    }
                }
            }
        });

        runtime::spawn(async move {
            loop {
                match await!(send_receiver.next()) {
                    Some(mut bytes) => {
                        println!("sent {:02X?}", &bytes[..]);
                        await!(writer.write_all(&bytes[..]));
                    },
                    None => {
                        println!("Send Channel: closed");
                        break;
                    }
                }
            }
        });
    }

    Ok(())
}



#[runtime::main]
async fn main() -> Result<(), failure::Error> {

    {
        use mapper::Decoder;

        let buffer = [0x1, 0x02, 0x00, 0x02, 0xff, 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x04];
        let mut pong = packet::Rora::decode(&buffer);
        drop(buffer);

        dbg!(pong.payload);
        dbg!(pong.payload2);
        pong.payloadList.iter().for_each(|n| {
            dbg!(n);
        });
        pong.payloadList.iter().for_each(|n| {
            dbg!(n);
        });
        for item in &pong.payloadList2 {
            item.iter().for_each(|n| {
                dbg!(n);
            });
        }


        use mapper::Encoder;
        dbg!(pong.encode());
        pong.payloadList = vec![0,1,2,3,4].into();
        dbg!(pong.encode());

        let mut arr = [0u8; 30];
        pong.encode_into(&mut &mut arr[..]);
        dbg!(&arr[..pong.size_enc()]);
    }

    /*
    let mock = mock! {
        Ok(b"\x0A\x00\x00\x00\x64\x00\x00\x00\x00\x01\x09\x00\x01\x00\x14\x00\x00\x00\x00".to_vec()),
    };

    {
        //let mut test_reader = FramedRead::new(mock, ProtocolCodec {});
       // println!("{:?}", await!(test_reader.next()));
       // println!("{:?}", await!(test_reader.next()));
       // println!("{:?}", await!(test_reader.next()));
    }
    */

    runtime::spawn(login_server());
    await!(char_server());

    Ok(())
}

