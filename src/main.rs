#![feature(generators)]
#![feature(const_fn)]

#[macro_use]
extern crate lazy_static;

use bytes::{Bytes, BytesMut};
use std::sync::atomic::{AtomicUsize, Ordering};
//use std::sync::{Arc, RwLock};

use async_std::io;
use async_std::net::{TcpListener, TcpStream, ToSocketAddrs};
use async_std::prelude::*;
use async_std::stream::{Stream, StreamExt};
use async_std::sync::channel;
use async_std::sync::{Arc, RwLock};
use async_std::task;
use async_std::task::{Context, Poll};
use futures::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use futures::sink::{Sink, SinkExt};
use async_std::sync::Sender;
use async_std::io::BufReader;

//use futures::prelude::*;
//use futures::task::Context;
//use futures::prelude::AsyncRead;
//use futures::{SinkExt, Poll};
use std::collections::HashMap;
use rand::AsByteSliceMut;

use mapper::Decoder;

pub mod cryptor;
pub mod packet;

#[derive(Debug)]
struct Client {
    pub id: usize,
    pub user_id: Option<usize>,

    pub writer: Sender<BytesMut>,
}

//impl<T: tokio::prelude::SinkExt<SinkItem=BytesMut, SinkError=mpsc::SendError> + std::marker::Unpin + Clone> Client<T> {
impl Client {
    pub async fn send(&self, mut bytes: BytesMut) {
        let len_bytes = u16::to_le_bytes(bytes.len() as u16);
        bytes[0] = len_bytes[0];
        bytes[1] = len_bytes[1];
        println!("sending {:02X?}", &bytes[..]);

        if bytes[2] == 1 {
            cryptor::decrypt_hybrid_64(&mut bytes[4..]);
        }

        self.writer.send(bytes.clone()).await
    }
}



#[derive(Debug)]
pub struct ProtocolCodec;

/*
impl Decoder for ProtocolCodec  {
    type Item = BytesMut;
    type Error = io::Error;

    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<BytesMut>> {
        if buf.len() >= 2
        {
            let len = u16::from_le_bytes([buf[0], buf[1]]) as usize;
            if buf.len() >= len {
                let mut result = buf.split_to(len);
                Ok(Some(result))
            } else {
                Ok(None)
            }
        } else {
            Ok(None)
        }
    }
}
*/

/*
// ===== Mock ======
use std::collections::VecDeque;
struct Mock {
    calls: VecDeque<io::Result<Vec<u8>>>,
}

macro_rules! mock {
    ($($x:expr,)*) => {{
        let mut v = VecDeque::new();
        v.extend(vec![$($x),*]);
        Mock { calls: v }
    }};
}

impl Read for Mock {
    fn read(&mut self, dst: &mut [u8]) -> io::Result<usize> {
        match self.calls.pop_front() {
            Some(Ok(data)) => {
                debug_assert!(dst.len() >= data.len());
                dst[..data.len()].copy_from_slice(&data[..]);
                Ok(data.len())
            }
            Some(Err(e)) => Err(e),
            None => Ok(0),
        }
    }
}

impl AsyncRead for Mock {

}
*/

struct PacketStream<R> {
    inner: R,
    buffer: BytesMut,
    index: usize,
}

impl<R: io::Read + std::marker::Unpin> PacketStream<R> {
    fn next_packet(&mut self) -> Option<BytesMut> {
        if self.index > 2 {
            let mut size = u16::from_le_bytes([self.buffer[0], self.buffer[1]]) as usize;
            if size <= self.index {
                self.index -= size;
                Some(self.buffer.split_to(size))
            } else {
                None
            }
        } else {
            None
        }
    }

    fn new(inner: R) -> PacketStream<R> {
        PacketStream {
            inner: inner,
            buffer: BytesMut::with_capacity(1024 * 10),
            index: 0,
        }
    }
}

// The receiver does not ever take a Pin to the inner T
impl<R> Unpin for PacketStream<R> {}

impl<R: io::Read + std::marker::Unpin> Stream for PacketStream<R> {
    type Item = BytesMut;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>> {
        let stream = self.get_mut();
        stream.buffer.resize(stream.index + 1024, 0);
        match std::pin::Pin::new(&mut stream.inner)
            .poll_read(cx, &mut stream.buffer[stream.index..stream.index + 1024])
        {
            Poll::Ready(Ok(len)) => {
                println!("ok {}", len);
                if len == 0 {
                    return Poll::Ready(None);
                }
                stream.index += len;
                let result = stream.next_packet();
                if result.is_none() {
                    Poll::Pending
                } else {
                    Poll::Ready(result)
                }
            }
            Poll::Ready(Err(e)) => {
                println!("err");
                let result = stream.next_packet();
                if result.is_none() {
                    Poll::Ready(None)
                } else {
                    Poll::Ready(result)
                }
            }
            Poll::Pending => {
                let result = stream.next_packet();
                if result.is_none() {
                    Poll::Pending
                } else {
                    Poll::Ready(result)
                }
            }
        }
    }
}

async fn login_server() -> Result<(), std::io::Error> {
    let ids = AtomicUsize::new(0);

    let mut listener = TcpListener::bind("0.0.0.0:20000").await?;
    println!("Listening on {}", listener.local_addr()?);

    use packet::send;

    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream: Arc<TcpStream> = Arc::new(stream?);

        println!("We got client {:?}", stream.peer_addr());

        //let (mut reader,mut writer) = stream.split();

        let (send_sender, mut send_receiver) = channel::<BytesMut>(20);

        let id = ids.fetch_add(1, Ordering::SeqCst);

        let client = Arc::new(Client {
            id: id,
            user_id: None,
            writer: send_sender,
        });

        let (recv_sender, mut recv_receiver) = channel::<BytesMut>(20);

        let reader = stream.clone();
        let writer = stream.clone();

        task::spawn(async move {
            let mut reader = PacketStream::new(&*reader);
            while let Some(packet) = reader.next().await {
                recv_sender.send(packet).await;
            }
            println!("Finished Reaciving :D");
        });

        task::spawn(async move {
            loop {
                match send_receiver.next().await {
                    Some(bytes) => {
                        println!("sent {:02X?}", &bytes[..]);
                        match (&*writer).write_all(&bytes[..]).await {
                            Ok(()) => println!("awd"),
                            Err(e) => println!("err {}", e),
                            _ => println!("dsa"),
                        };
                    }
                    None => {
                        println!("Send Channel: closed");
                        break;
                    }
                }
            }
        });

        task::spawn(async move {
            {
                let buff = [0x0A, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01];
                let buff = BytesMut::from(&buff[..]);

                client.send(buff).await;
            }

            loop {
                match recv_receiver.next().await {
                    Some(mut bytes) => {
                        if bytes[2] == 0x01 {
                            cryptor::decrypt_hybrid_64(&mut bytes[4..]);
                        }
                        let header = packet::Header::decode(&bytes[..8]);
                        let data = &mut bytes[8..];
                        println!("recv {:02X?}", &data[..]);
                        println!("header {:02X?}", header.id);

                        match header.id {
                            0x65 => {
                                let packet = packet::Packet::new(send::Hello::new());
                                client.send(packet.into()).await;
                            }
                            0xBEBC207 => {
                                let buff = [
                                    0x49, 0x00, 0x01, 0x00, 0x01, 0xC2, 0xEB, 0x0B, 0x00, 0xE7,
                                    0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x56,
                                    0x6F, 0x76, 0x63, 0x68, 0x69, 0x6B, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;
                            }
                            0x012C => {
                                let buff = [
                                    0x18, 0x00, 0x01, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x01, 0x00,
                                    0x31, 0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x07,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;

                                let buff = [
                                    0x76, 0x00, 0x01, 0x00, 0x69, 0xD2, 0xEB, 0x0B, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;

                                let buff = [
                                    0x10, 0x00, 0x01, 0x00, 0x2D, 0x01, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;
                            }
                            0xBEBC264 => {
                                let buff = [
                                    0x0c, 0x00, 0x01, 0x00, 0x65, 0xC2, 0xEB, 0x0B, 0x01, 0x01,
                                    0x00, 0x53, 0x65, 0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x31,
                                    0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x07, 0x01, 0x02,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;
                            }
                            0xBEBC268 => {
                                let buff = [
                                    0x0c, 0x00, 0x01, 0x00, 0x69, 0xC2, 0xEB, 0x0B, 0x08, 0x6A,
                                    0x00, 0x43, 0x48, 0x5F, 0x30, 0x36, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00,
                                    0x43, 0x48, 0x5F, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x43,
                                    0x48, 0x5F, 0x30, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x43, 0x48,
                                    0x5F, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0x43, 0x48, 0x5F,
                                    0x30, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x68, 0x00, 0x43, 0x48, 0x5F, 0x30,
                                    0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x00, 0x6C, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x38,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00, 0x6B, 0x00, 0x43, 0x48, 0x5F, 0x30, 0x37, 0x00,
                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x00,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;
                            }
                            0xBEBC26B => {
                                let buff = [
                                    0x0c, 0x00, 0x01, 0x00, 0x6C, 0xC2, 0xEB, 0x0B, 0x00, 0x31,
                                    0x32, 0x37, 0x2E, 0x30, 0x2E, 0x30, 0x2E, 0x31, 0x00, 0x00,
                                    0x00, 0xD2, 0x07,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;
                            }
                            0x012e => {
                                let buff = [
                                    0x0c, 0x00, 0x01, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x00, 0x00,
                                    0x00, 0x00,
                                ];
                                let buff = BytesMut::from(&buff[..]);
                                client.send(buff).await;
                            }
                            _ => println!("Unknown id {:02X?}", header.id),
                        }
                    }
                    None => {
                        println!("Recv Channel: closed");
                        break;
                    }
                }
            }
        });
    }

    Ok(())
}

async fn char_server() -> Result<(), std::io::Error> {
    let clients = Arc::new(RwLock::new(HashMap::new()));
    let ids = AtomicUsize::new(0);

    let mut listener = TcpListener::bind("0.0.0.0:2001").await?;
    println!("Listening on {}", listener.local_addr()?);

    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream: Arc<TcpStream> = Arc::new(stream?);

        let reader = stream.clone();
        let writer = stream.clone();

        let (send_sender, mut send_receiver) = channel::<BytesMut>(20);
        let (recv_sender, mut recv_receiver) = channel::<BytesMut>(20);

        let id = ids.fetch_add(1, Ordering::SeqCst);
        let client = Arc::new(Client {
            id: id,
            user_id: None,
            writer: send_sender,
        });

        let clients = clients.clone();
        loop {
            match clients.try_write() {
                Some(mut hash) => {
                    println!("Insert Client {}", id);
                    hash.insert(id, client.clone());
                    break;
                }
                _ => {}
            }
        }

        {
            let buff = [0x0A, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01];
            let buff = BytesMut::from(&buff[..]);

            client.send(buff).await;
        }

        task::spawn(async move {
            let mut reader = PacketStream::new(&*reader);
            while let Some(packet) = reader.next().await {
                recv_sender.send(packet).await;
            }
            println!("Finished Reaciving :D");

            loop {
                match clients.try_write() {
                    Some(mut hash) => {
                        println!("Remove Client DC {}", id);
                        hash.remove(&id);
                        break;
                    }
                    _ => {}
                }
            }
        });

        task::spawn(async move {
            loop {
                match send_receiver.next().await {
                    Some(bytes) => {
                        println!("sent {:02X?}", &bytes[..]);
                        (&*writer).write_all(&bytes[..]).await.unwrap();
                    }
                    None => {
                        println!("Send Channel: closed");
                        break;
                    }
                }
            }
        });

        task::spawn(async move {
            loop {
                match recv_receiver.next().await {
                    Some(mut bytes) => {
                        if bytes[2] == 1 {
                            cryptor::decrypt(&mut bytes[4..]);
                        }
                        println!("recv {:02X?}", &bytes[..]);

                        if bytes[4] == 0x65 {
                            let buff = [
                                0x0c, 0x00, 0x01, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00,
                            ];
                            let buff = BytesMut::from(&buff[..]);
                            client.send(buff).await;
                        }
                        if bytes[4] == 0x2c {
                            let buff = [
                                0x10, 0x00, 0x01, 0x00, 0x2D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                            ];
                            let buff = BytesMut::from(&buff[..]);
                            client.send(buff).await;
                        }
                        if bytes[4] == 0xCC {
                            let buff = [
                                0x0c, 0x00, 0x01, 0x00, 0xF1, 0xC2, 0xEB, 0x0B, 0x00, 0x01, 0x00,
                                0x00, 0x00, 0x00, 0x01,
                            ];
                            let buff = BytesMut::from(&buff[..]);
                            client.send(buff).await;

                            let buff = [
                                0x0c, 0x00, 0x01, 0x00, 0xF1, 0xC2, 0xEB, 0x0B, 0x00, 0x02, 0x67,
                                0xDC, 0x01, 0x00, 0x01, 0x00, 0x10, 0x30, 0x64, 0x44, 0x6F, 0x6F,
                                0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0xFF, 0x00, 0x00, 0x01, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35,
                                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x09, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x85, 0xCE, 0x38, 0x01,
                                0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x25,
                                0xD1, 0xCC, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
                                0x00, 0x03, 0x85, 0x2B, 0xC1, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x08, 0x00, 0x00, 0x00, 0x04, 0x05, 0xC2, 0x59, 0x08, 0x01, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x05, 0x85, 0x58, 0xF2,
                                0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0D,
                                0xFE, 0xC5, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00,
                                0x00, 0x00, 0x04, 0x51, 0x2D, 0x3B, 0x01, 0x01, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x07, 0x00, 0x00, 0x00, 0x05, 0x51, 0xA9, 0xCD, 0x01, 0x01,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x51, 0x03,
                                0x30, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            ];
                            let buff = BytesMut::from(&buff[..]);
                            client.send(buff).await;

                            let buff = [0x0c, 0x00, 0x01, 0x00, 0xF1, 0xC2, 0xEB, 0x0B, 0x00, 0x03];
                            let buff = BytesMut::from(&buff[..]);
                            client.send(buff).await;
                        }
                    }
                    None => {
                        println!("Recv Channel: closed");
                        break;
                    }
                }
            }
        });
    }

    Ok(())
}

fn main() -> io::Result<()> {
    {
        use color_backtrace;
        color_backtrace::install();
    }

    let buff: Vec<u8> = (0..100u8).collect();
    let mut buff = BytesMut::from(&buff[..]);

    {
         println!("{:?}", buff.split_to(10));
    }
    buff.resize(100, 0);
    println!("{} {:?}", buff.capacity(), buff);
    /*
    let mock = mock! {
        Ok(b"\x0A\x00\x00\x00\x64\x00\x00\x00\x00\x01\x09\x00\x01\x00\x14\x00\x00\x00\x00".to_vec()),
    };

    {
        //let mut test_reader = FramedRead::new(mock, ProtocolCodec {});
       // println!("{:?}", await!(test_reader.next()));
       // println!("{:?}", await!(test_reader.next()));
       // println!("{:?}", await!(test_reader.next()));
    }
    */
    task::spawn(login_server());
    task::block_on(char_server())
}
